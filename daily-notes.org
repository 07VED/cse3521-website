#+SETUPFILE: setup.org
#+TITLE: Daily notes

* Day 1

** What is AI?

- [act/think] [rationally/humanly]

  - act rationally: do the correct things in
    the world

  - act humanly: do the things the human would
    do in the world

  - think rationally: use the best algorithms
    to get the correct results

  - think humanly: the AI system has internal
    representations and algorithms like human
    cognition

** Examples of AI

- system that designs video games
- IBM's Watson: won Jeopardy!, healthcare
- Siri
- IBM Deep Blue, beat Kasparov 1997, "Game Over",
  used specialized chips that play chess
- Google's autonomous vehicles
- Google bought Boston Dynamics
- Amazon Air (drones)
- Video game AI
- robots that learn new languages like toddlers do
- drone fighting drones
- military drones
- Google Glass
- Google Search
- Google Ads
- Google Now
- Google Then
- Google Future
- Machine Learning, Data Mining
- Fraud detection

* Day 2

** How do we test for AI?

- put it in a human situation and see if it comes to the same
  decisions as a human
  - maybe just report its decisions, not act on them
  - maybe also physically does the same things (if it has arms
    and legs, etc.)
- give it human tests for intelligence, IQ tests, SATs, LSAT,
  behavioral tests
- Voigt-Kampff test
- Turing Test
- interact with people who don't know it's a robot
- mock tests of certain scenarios
- see if you can tell the difference between human and machine
- human-robot chat
- see if it has self-preservation tendencies
- ask how it feels, emotions
- listen to a song with it, then ask it how the song makes it feel
- put it in a paradoxical situation, ethical conundrum
  - save your dog or the child
- ask any question about any topic to see how it responds
- job interview
- meet the president, or the Queen


** The Turing Test

*** The imitation game

- A man (A), a woman (B), and a judge (C)
- The judge cannot see A or B (or hear them)
- The judge must determine who is the woman
- The man (A) wants to convince the judge that he is a woman
  - AND, (harder) that the woman is NOT a woman
- And the woman (B) is trying to convince the judge that she is
  the woman
- If the man succeeds, then we can say he is intelligent

*** Replace the man with a machine

- now the machine (A) is trying to convince the judge that it
  is the woman
  - woman still trying to say she is the woman

- we often think of it as the machine trying to convince the judge
  that it is the human

*** What's "success"?

- How often (%) must the man convince the judge that he is the
  woman to be considered a good woman imitator?
  - about 25%
  - Turing said 30% would be good enough


** Dennett's weaker versions

- Chess (beating Kasparov)
  - doesn't cover range of intelligence
  - isolatable skill
- Solves the Arab-Israeli conflict
  - harder than the TT
  - unrepeatable
  - slow
  - not clear what is considered winning
- Steals the crown jewels
  - might be able to find security vulnerabilities
  - luck
  - ethically dubious

** Langley's challenges

- Synthetic entertainer
  - American AIdoll
- Synthetic attorney
- Synthetic politician



* Day 3

** Python

This is the code we played with. Try it out yourself at the "REPL"
(just run =python= from your console).

#+BEGIN_SRC python
x = 5
print x
while x > 0:
    print x
    x -= 1

mylist = ["bob", "jane", "alice"]
print mylist

for name in mylist:
    print name

print enumerate(mylist)
print list(enumerate(mylist))
for (i, name) in enumerate(mylist):
    print "index is", i, "and name is", name

mylist2 = [(1, 2, 3), (4, 5, 6)]
for (x, y, z) in mylist2:
    print x, y, z

mystack = []
mystack.append('A')
print mystack
mystack.append('B')
print mystack
print mystack.pop()
print mystack

from collections import deque
myqueue = deque()
print myqueue
myqueue.append('A')
myqueue.append('B')
print myqueue
print myqueue.popleft()
print myqueue
print myqueue.pop()
print myqueue

mylist = ["bob", "jane", "alice"]
print mylist[0]
print mylist[0:1]
print mylist[0:2]
print mylist[0:3]
print mylist[1:3]
print mylist[1:2]
print mylist[1:-1]
print mylist[1:-2]
print mylist[0:-2]
print mylist[-1]
print mylist[-2]
print mylist[-2:0]

# This page describes "list splicing":
# http://stackoverflow.com/questions/509211/pythons-slice-notation

# reverse a string or list:
mystring = "mystring"
print mystring[::-1]

def myfunc(x):
    return x+1

print myfunc(52)

def myfunc(x):
    return (x, x+1)

print myfunc(52)

def myfunc(x=5):  # default value for x
    print x

myfunc()
myfunc(10)

class MyClass:
    def myclassfunc(self, x):
        print x

myobj = MyClass()
myobj.myclassfunc(10)

class MyClass:
    # the constructor
    def __init__(self):
        self.timesExecuted = 0
    def myclassfunc(self):
        self.timesExecuted += 1
        print self.timesExecuted

myobj = MyClass()
myobj.myclassfunc()  # prints 1
myobj.myclassfunc()  # prints 2
myobj.myclassfunc()  # prints 3
#+END_SRC

** Search

*** Example: Wolves & chicks

    - Take three chicks and three wolves across the river
    - If there is a wolf on one side, it will eat the chicks
    - Boat only holds two animals

    - Initial state :: Three wolves and three chicks on same side

    - Possible actions :: Put a chick on the boat, put a wolf
         on the boat, move the boat across

    - Transition model :: A function from state to [list of states]
         and for this problem, the list of states are those
         that do not kill the chicks

    - Goal criteria :: All on other side

    - Path cost :: A function from list of states/actions to
         some kind of cost; 
         sometimes you want the least-cost solution



** Basic BFS algorithm:

#+BEGIN_SRC
   - openset = [start] # places I know about, but haven't been to
   - closedset = [] # places I have been to
   - while len(openset) > 0:  # i.e., openset not empty
     - state = openset.popleft() # I want a queue/deque
     - closedset.append(state)
     - if state == goal:
       - done
     - else:
       - for next_state in possible_moves(state):
         - if next_state not in closedset:
             - openset.append(next_state)
#+END_SRC

** Basic DFS algorithm:

#+BEGIN_SRC
   - openset = [start] # places I know about, but haven't been to
   - closedset = [] # places I have been to
   - while len(openset) > 0:  # i.e., openset not empty
     - state = openset.pop() # I want a stack  <------- ONLY DIFFERENCE FROM BFS
     - closedset.append(state)
     - if state == goal:
       - done
     - else:
       - for next_state in possible_moves(state):
         - if next_state not in closedset:
             - openset.append(next_state)
#+END_SRC


* Day 4

** Informed search

   - what is a "better" solution to the Goodale problem?
     - faster i.e. less time
   - what information would you use to solve the Goodale problem better?
     - traffic information: how long it takes to make the next move
     - distance
     - speed limits
     - stop lights

* Day 5

** Pacman

   - your function should return something like:
     [NORTH, SOUTH, SOUTH, WEST]


   - parents[next_state] = (state, action)

   - later, to reconstruct the path:
     - you know the goal, call it "state"
     - create an empty list of actions:
       - actions = []
       - then put stuff in it iteratively, by referring
         to the parents map:
         - while state in parents:
           - (prior_state, action) = parents[state]

** Heuristics for 8-puzzle
   - number of pieces out of place
   - sum of manhattan distances for each piece to where it
     needs to go
** Heuristics for Goodale routing
   - straight-line distance from state to goal
     - calculate with lat/lon
   - length of street & speed limit
     - factor in traffic
   - manhattan distance from state to goal
** Hill-climbing
   - take "best" according to heuristic,
     then delete the openset
** Best-first search
   - take "best" according to heuristic,
     but use openset as usual
** Again with the heuristics
   - "admissible": ALWAYS underestimates or is perfect
   - impact: if it's admissible, the search will always
     find the best path
   - when h(s) is admissible, it's called h*(s)
*** Goodale
    - is straight-line distance "admissible"?
      - yes, can't go faster than straight-line
    - road distance * speed limit: admissible?
      - no, might get there faster (drive over the speed limit)
    - manhattan distance is not admissible
** A*
  - The search algorithm that uses f*(s) = g(s) + h*(s)
    is called A*
** Websites
   - http://qiao.github.io/PathFinding.js/visual/
   - https://www.youtube.com/watch?v=g418BSF6XBQ (SimCity)
   - https://www.youtube.com/watch?v=WTDS3EhGH4w (SimCity)

* Day 6

** A*

#+BEGIN_EXAMPLE
1. create an empty list called "closedset"; this list will contain
   states that have been visited

2. create a list called "openset" that contains just the starting
   state; this list contains states that have not been visited but are
   known to exist

2.a. create a list called "openset_states" that contains just the states
     that would otherwise be in openset

3. create an empty map (key/value pairs) called "parents"; this map
   contains the previous state of each state that has been visited

4. while the openset is not empty:

   a. grab a state from the openset (and remove it from both sets);
      put it in the closedset (since we're now looking at it)

      - we need to prefer better states first

   b. if that state is the goal, hey we're done!

      i. return a reconstructed path from the goal state to the start
         state (this is easy: recursively grab parent states from the
         "parents" map)

   c. it's not the goal state; for each next state that is accessible
      from here:

       i. if this next state is in the closedset (it has been visited
          before), ignore it

      ii. if this next state is not in the openset, put it in the
          openset and record its parent

          - if state not in openset_states:

   d. (repeat the loop)

5. if the openset is empty and we never found the goal, oops!
#+END_EXAMPLE

** Heaps

   - heaps are ordered lists
     - stuff is sorted by what its value is:
       - best to use: (score, state) tuples

** Cost functions (path-cost + heuristic)

*** What's the number associated with a state?

    - You can get BFS behavior if you do this:
      - cost = number of steps in the path
      - i.e., cost of path to here, + 1
      - bottom-up approach:
        - when you find successors,
          - record in another map, path cost + 1

#+BEGIN_SRC python
for (next_state, action, cost) in problem.getSuccessors(state):
    # next_state is something like (4, 2) (coordinates)
    # action is something like WEST
    # cost is not used for depth-first search

    path_cost = 0
    if state in path_costs:
        path_cost = path_costs[state] + cost
    path_costs[next_state] = path_cost

    # path_cost is g(s) in the formula f*(s) = g(s) + h*(s)

    # btw, BFS is f(s) = g(s)
    # btw, DFS is f(s) = -g(s)
    # btw, best-first is f(s) = h(s)
    # btw, A is f(s) = g(s) + h(s)
    # btw, A* is f*(s) = g(s) + h*(s)

    # two options for h*(s): manhattanHeuristic, euclideanHeuristic,
    #                        nullHeuristic

    total_cost = path_cost + heuristic(next_state, problem)

    heappush(openset, (total_cost, next_state))
    openset_states.push(next_state)
#+END_SRC

























































































































#+INCLUDE: footer.org
