<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Adversarial search</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="css/worg.css" type="text/css" media="screen" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<a href="index.html">Home</a> &nbsp; &nbsp;
          <!-- Plupper Button -->
          <div id="plupperButton" style="display: inline;"></div>
          <!-- End of Plupper Button Code -->
</div>
<div id="content">
<h1 class="title">Adversarial search</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Expansion of the search problem</a></li>
<li><a href="#sec-2">I move, you move, etc.</a></li>
<li><a href="#sec-3">Minimax algorithm</a>
<ul>
<li><a href="#sec-3-1">Python code for minimax</a></li>
<li><a href="#sec-3-2">Python code for tic-tac-toe components</a></li>
</ul>
</li>
<li><a href="#sec-4">Alpha-beta pruning</a>
<ul>
<li><a href="#sec-4-1">Python code for alpha-beta pruning</a></li>
</ul>
</li>
<li><a href="#sec-5">A poor example?</a></li>
<li><a href="#sec-6">I can't help myself</a></li>
</ul>
</div>
</div>
<p>
#+BEGIN_QUOTE

"It was a watershed event, but it doesn't have to do with computers
becoming intelligent," said Douglas Hofstadter, a professor of
computer science at Indiana University and author of several books
about human intelligence, including <i>GÃ¶del, Escher, Bach</i>, which won a
Pulitzer Prize in 1980, with its witty argument about the connecting
threads of intellect in various fields of expression. "They're just
overtaking humans in certain intellectual activities that we thought
required intelligence. My God, I used to think chess required thought.
Now, I realize it doesn't. It doesn't mean Kasparov isn't a deep
thinker, just that you can bypass deep thinking in playing chess, the
way you can fly without flapping your wings." &#x2014; Bruce Weber,
"<a href="http://www.rci.rutgers.edu/~cfs/472_html/Intro/NYT_Intro/ChessMatch/MeanChessPlaying.html">Mean
Chess-Playing Computer Tears at Meaning of Thought</a>," The New York
Times, Feb 19, 1996

#+END_QUOTE

Chess, tic-tac-toe, connect-four, checkers, go, etc. etc. are
<i>zero-sum games</i>, meaning in the end, the gains and losses among the
players add up to zero. In the examples listed, one player wins,
another loses, so the sum of "utility" for each player at the end is
zero.

Poker is another zero-sum game, although there is one winner and many
losers. However, the amount the winner wins is equal to the sum of the
amounts the losers lose.

Study of zero-sum games began the study of game theory, which is a
mathematical subject that covers any situation involving several
agents attempting to make decisions that maximize their own utility.

We will not be studying game theory, as a whole, but we will learn how
to "play" zero-sum games.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Expansion of the search problem</h2>
<div class="outline-text-2" id="text-1">
<p>
The components of a search problem included the following:
</p>
<dl class="org-dl">
<dt> Initial state </dt><dd>some description of the agent's starting situation
</dd>
</dl>

<dl class="org-dl">
<dt> Possible actions </dt><dd>the set of actions (such as chess moves)
available to the agent, also called "applicable" actions; the
possible actions depend on the state
</dd>
</dl>

<dl class="org-dl">
<dt> Transition model </dt><dd>some way of figuring out what an action <i>does</i>;
in other words, a <code>resultOf(state, action)</code> function which
returns a state; the transition model defines a state space,
which takes the form of a directed graph (vertices are states,
edges are actions)
</dd>
</dl>

<p>
Note that we have left out "Goal criteria" and "Path cost." In order
to support adversarial search, we add the following:
</p>
<dl class="org-dl">
<dt> Players </dt><dd>a list of players (we'll look at 2-player games) and a
<code>switch_player(player)</code> function that switches to the
player following =player=
</dd>
</dl>

<dl class="org-dl">
<dt> Terminal tests </dt><dd>a function or functions that test for final states
(winning/losing/tied states)
</dd>
</dl>

<dl class="org-dl">
<dt> Utility function </dt><dd>a function <code>utility(state, player)</code> that returns
a real number (or integer) representing the value to <code>player</code> of
<code>state</code>; presumably, winning states have the highest utility,
losing states the lowest utility, tied states have zero utility,
and states that are not terminal have a utility calculated by
looking at the utilities of following states
</dd>
</dl>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">I move, you move, etc.</h2>
<div class="outline-text-2" id="text-2">
<p>
The simplest zero-sum games are those that have two players who take
turns. Chess, tic-tac-toe, etc. fit this definition. Suppose a human
is playing a computer. The computer needs to figure out which move is
best (the computer wants to maximize the utility of its move). We
learned how to search (BFS, DFS, A*, and so on), but even though the
computer will be engaging in a search, those search algorithms will
not help us here.

BFS, DFS, A* and so on attempt to maximize (or minimize) every choice
equally (for example, we want to find the shortest route). But in a
game search, instead we want to maximize the payoff of our choices but
minimize the payoff of the other player's choices.

The way to do this is to treat the opponent's positive utility as our
negative utility. So if the opponent makes a winning move, that move
is worth 1.0 to the opponent but worth -1.0 to us (a tie game has
utility 0.0 for both players). We want to find the move that maximizes
our utility (best case, 1.0) and minimizes the opponent's utility
(best case, -1.0).
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Minimax algorithm</h2>
<div class="outline-text-2" id="text-3">
<p>
The minimax algorithm does exactly that: it finds the move that
minimizes the maximum utility the opponent can obtain. You can call it
"maximin" if you'd like: maximize the minimum utility we (not the
opponent) can obtain. They are the same algorithm, just the order of
the steps (maximize or minimize) is different.

First, we consider all of our possible moves. If a move is a final
move (winning/losing/tie), then we calculate its utility directly (1.0
for a win, -1.0 for a loss, 0.0 for a tie). If it's not a final move,
we have to look further to calculate its utility. We choose one move
from which to "look further," and consider all the possible moves the
opponent might make. If the opponent wins, the utility of the
opponent's move is -1.0. Of all the possible moves the opponent might
make, we find the worst (minimum) utility. That utility is the value
of our move.

Of all our possible moves, we choose the one that has the maximum
utility; it is the maximum of the minimum utilities generated by the
opponent's moves. We are assuming the opponent is also choosing the
best move, so when we choose our move, we want to find the move that
performs best (max) assuming the opponent also performs best (min;
i.e., max for the opponent, min for us).

Here is an example search tree for tic-tac-toe. We basically have a
depth-first search but also propogate information about utilities (max
or min) upwards.


#+BEGIN_HTML
&lt;div style="text-align: center"&gt;
&lt;OBJECT CLASSID="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" 
WIDTH="474" HEIGHT="550"
CODEBASE="<a href="http://active.macromedia.com/flash5/cabs/swflash.cab#version=5,0,0,0">http://active.macromedia.com/flash5/cabs/swflash.cab#version=5,0,0,0</a>"&gt;
&lt;PARAM NAME="MOVIE" VALUE="./flash/ttt-minimax-example.swf"&gt;
&lt;PARAM NAME="PLAY" VALUE="true"&gt;
&lt;PARAM NAME="QUALITY" VALUE="best"&gt;
&lt;PARAM NAME="LOOP" VALUE="true"&gt;
&lt;EMBED SRC="./flash/ttt-minimax-example.swf" WIDTH="474" HEIGHT="550" PLAY="true" LOOP="true" QUALITY="best" 
PLUGINSPAGE="<a href="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash">http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash</a>"&gt; 
&lt;/EMBED&gt;
&lt;/OBJECT&gt;
&lt;br/&gt;
&lt;a href="./images/ttt-minimax-example.png"&gt;View final image&lt;/a&gt;
&lt;/div&gt;
#+END_HTML
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Python code for minimax</h3>
<div class="outline-text-3" id="text-3-1">
<p>
#+BEGIN_SRC python
def minimax(state):
    max_trans = None
    max_u = None
    transitions = possible_transitions(state, 'x')
</p>
<p>
for trans, nextstate in transitions.iteritems():
</p>
<p>
        u = min_utility(nextstate, 'o')
        if max_u is None or u &gt; max_u:
            max_trans = trans
            max_u = u
    return max_trans

def min_utility(state, player):
</p>
<p>
if is_winning(state, player) or \
        is_winning(state, switch_player(player)) or \
        is_tie(state):
    return utility(state, 'x')
else:
    transitions = possible_transitions(state, player)
    min_u = None
    for nextstate in transitions.values():
</p>
<p>
            u = max_utility(nextstate, switch_player(player))
            if min_u is None or u &lt; min_u:
                min_u = u
        return min_u

def max_utility(state, player):
</p>
<p>
if is_winning(state, player) or \
        is_winning(state, switch_player(player)) or \
        is_tie(state):
    return utility(state, 'x')
else:
    transitions = possible_transitions(state, player)
    max_u = None
    for nextstate in transitions.values():
</p>
<p>
            u = min_utility(nextstate, switch_player(player))
            if max_u is None or u &gt; max_u:
                max_u = u
        return max_u
#+END_SRC
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Python code for tic-tac-toe components</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Here is some code for tic-tac-toe specific components used by the
minimax algorithm. Not all the code needed to play tic-tac-toe is
shown here, however.

#+BEGIN_SRC python
def switch_player(player):
    if player == 'x': return 'o'
    else: return 'x'

def is_winning(state, player):
    winning = False
    for i in [0,1,2]:
        if state[i]<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup> <code>= state[i][1] =</code> state[i]<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup> == player:
            winning = True
    for j in [0,1,2]:
        if state<sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup>[j] <code>= state[1][j] =</code> state<sup><a id="fnr.2.100" name="fnr.2.100" class="footref" href="#fn.2">2</a></sup>[j] == player:
            winning = True
    if state<sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup><sup>, </sup><sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup> <code>= state[1][1] =</code> state<sup><a id="fnr.2.100" name="fnr.2.100" class="footref" href="#fn.2">2</a></sup><sup>, </sup><sup><a id="fnr.2.100" name="fnr.2.100" class="footref" href="#fn.2">2</a></sup> == player:
        winning = True
    if state<sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup><sup>, </sup><sup><a id="fnr.2.100" name="fnr.2.100" class="footref" href="#fn.2">2</a></sup> <code>= state[1][1] =</code> state<sup><a id="fnr.2.100" name="fnr.2.100" class="footref" href="#fn.2">2</a></sup><sup>, </sup><sup><a id="fnr.1.100" name="fnr.1.100" class="footref" href="#fn.1">1</a></sup> == player:
        winning = True
    return winning

def is_tie(state):
    blanks = 0
    for i in [0,1,2]:
        for j in [0,1,2]:
            if state[i][j] <code>= ' ': blanks +</code> 1
    return(blanks == 0 and \
               not is_winning(state, 'x') and \
               not is_winning(state, 'o'))

def utility(state, player):
    if is_winning(state, player): return 1
    if is_winning(state, switch_player(player)): return -1
    return 0
#+END_SRC
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Alpha-beta pruning</h2>
<div class="outline-text-2" id="text-4">
<p>
The minimax search is very costly. Far too many states are
searched. We can use a very simple, and somewhat obvious, optimization
to search only a fraction as many states while coming up with the
exact same answer as minimax.

The key insight is that when we are performing the "max" step (or
equivalently, the "min" step), if we find that a certain move gives a
maximum utility X (by searching its entire subtree), we can avoid any
searches of subtrees whose minimum value is less than X.

Look here, from <code>min_utility</code> (similar code is found in <code>max_utility~
and ~minimax</code> functions as well):

#+BEGIN_SRC python
min_u = None
for nextstate in transitions.values():
</p>
<p>
    u = max_utility(nextstate, switch_player(player))
    if min_u is None or u &lt; min_u:
        min_u = u
return min_u
#+END_SRC

The variable <code>min_u</code> here will only get smaller. Recall that the
utility that <code>min_utility</code> returns will be used by the <code>max_utility~
function. So different calls to ~min_utility</code> will be compared to pick
out the maximum <code>min_utility</code> value. Suppose the <code>min_utilty</code> function
was told (via a parameter) that some other call to ~min_utility~
produced a minimum utility of &alpha;, and that so far, &alpha; is the
greatest minimum utility found so far (the maximum of the
minimums).

Then if <code>min_u</code> ever goes smaller than &alpha;, there is no reason to
continue searching the other transitions (game moves), because ~min_u~
can only go smaller (being a minimum), and any value smaller than
&alpha; (the previously-found maximum <code>min_u</code> produced by earlier
function calls) will simply be ignored when maximizing.

The same can be said about <code>max_u</code> in the <code>max_utility</code> function; we
use the &beta; parameter to keep track of the smallest <code>max_u</code> so far
seen.

When maximizing (in <code>max_utility</code>), we will only change &alpha; because
we want to know the maximum of the minimums (&alpha; is the greatest
lower bound); when minimizing (in <code>min_utility</code>), we will only change
&beta;.
</p>
<dl class="org-dl">
<dt> &alpha; </dt><dd>the utility of the best (highest-value) choice we have
found so far at any choice point along the path in the
"max" mode of minimax
</dd>
</dl>

<dl class="org-dl">
<dt> &beta; </dt><dd>the utility of the best (lowest-value) choice for the
"min" mode of minimax
</dd>
</dl>

<p>
As we search down the tree, we provide the recursive search procedure
our currently-known best &alpha; and &beta;. If the recursive search
sees that some subtree cannot give any utility better than &alpha; (or
worse than &beta;) then we don't bother searching further from there.

It's very important to realize that the alpha-beta pruning procedure
does not produce different answers than minimax. Alpha-beta pruning
simply does not bother checking subtrees when it is certain those
subtrees will not change the answer produced by minimax.

Check out the <a href="./images/ttt-alphabeta-example.png">final search
graph</a> of another tic-tac-toe example, this time with alpha-beta
pruning. For comparison, <a href="./images/ttt-minimax-example-2.png">this is
the search graph without alpha-beta pruning</a>.

Alpha-beta pruning performs <i>much</i> better than vanilla minimax:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">Number of x/o tokens on the board</th>
<th scope="col" class="right">Average minimax states checked</th>
<th scope="col" class="right">Average &alpha;-&beta; states checked</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">0</td>
<td class="right">549946.0</td>
<td class="right">29019.0</td>
</tr>

<tr>
<td class="right">2</td>
<td class="right">7293.0</td>
<td class="right">1308.0</td>
</tr>

<tr>
<td class="right">4</td>
<td class="right">176.2</td>
<td class="right">81.8</td>
</tr>

<tr>
<td class="right">6</td>
<td class="right">11.0</td>
<td class="right">9.2</td>
</tr>

<tr>
<td class="right">8</td>
<td class="right">1.3</td>
<td class="right">1.3</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Python code for alpha-beta pruning</h3>
<div class="outline-text-3" id="text-4-1">
<p>
The minimax code above needs few modifications to support alpha-beta
pruning:

#+BEGIN_SRC python
def minimax_ab(state):
    max_trans = None
    max_u = None
    alpha = None
    beta = None
    transitions = possible_transitions(state, 'x')
</p>
<p>
for trans, nextstate in transitions.iteritems():
</p>
<p>
u = min_utility_ab(nextstate, 'o', alpha, beta)
if max_u is None or u &gt; max_u:
    max_trans = trans
    max_u = u
</p>
<p>
if beta is not None and u &gt;= beta:
    return trans
</p>
<p>
        if alpha is None or u &gt; alpha:
            alpha = u
    return max_trans

def min_utility_ab(state, player, alpha, beta):
</p>
<p>
if is_winning(state, player) or \
        is_winning(state, switch_player(player)) or \
        is_tie(state):
    return utility(state, 'x')
else:
    transitions = possible_transitions(state, player)
    min_u = None
    for nextstate in transitions.values():
</p>
<p>
u = max_utility_ab(nextstate, switch_player(player), alpha, beta)
if min_u is None or u &lt; min_u:
    min_u = u
</p>
<p>
if alpha is not None and u &lt;= alpha:
    return u
</p>
<p>
            if beta is None or u &lt; beta:
                beta = u
        return min_u

def max_utility_ab(state, player, alpha, beta):
</p>
<p>
if is_winning(state, player) or \
        is_winning(state, switch_player(player)) or \
        is_tie(state):
    return utility(state, 'x')
else:
    transitions = possible_transitions(state, player)
    max_u = None
    for nextstate in transitions.values():
</p>
<p>
u = min_utility_ab(nextstate, switch_player(player), alpha, beta)
if max_u is None or u &gt; max_u:
    max_u = u
</p>
<p>
if beta is not None and u &gt;= beta:
    return u
</p>
<p>
            if alpha is None or u &gt; alpha:
                alpha = u
        return max_u
#+END_SRC
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">A poor example?</h2>
<div class="outline-text-2" id="text-5">
<p>
Tic-tac-toe is such a simple game that minimax and alpha-beta pruning
are not really necessary. Apparently, here is optimal play (from
<a href="http://xkcd.com/832/">xkcd</a>):

#+BEGIN_CENTER
<img src="./images/xkcd-tic_tac_toe.png" alt="xkcd-tic_tac_toe.png" />
#+END_CENTER
</p>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">I can't help myself</h2>
<div class="outline-text-2" id="text-6">
<p>
This is also instructive (from <a href="http://xkcd.com/1002/">xkcd</a>):

#+BEGIN_CENTER
<img src="./images/xkcd-game_ais.png" alt="xkcd-game_ais.png" />
#+END_CENTER
</p>
<div style="font-size: 80%; clear: both;"> <span
xmlns:dct="http://purl.org/dc/terms/"
href="http://purl.org/dc/dcmitype/Text" property="dct:title"
rel="dct:type">Intro to AI material</span> by <a
xmlns:cc="http://creativecommons.org/ns#"
href="http://cse3521.artifice.cc" property="cc:attributionName"
rel="cc:attributionURL">Joshua Eckroth</a> is licensed under a <a
rel="license"
href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons
Attribution-ShareAlike 3.0 Unported License</a>. Source code for this
website available at <a
href="https://github.com/joshuaeckroth/cse3521-website">GitHub</a>.
</div>

<!-- Plupper Tracking Code -->
<script src="https://www.google.com/jsapi"></script>
<script type="text/javascript"
    src="https://static.plupper.com/js/plupper.js"></script>
<script type="text/javascript">
    plupper.init("joshuaeckroth@plupper.com");
    plupper.enableCobrowsing();
</script>
<!-- End of Plupper Tracking Code -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-23971505-3', 'artifice.cc');
  ga('send', 'pageview');

</script>

<script src="http://code.jquery.com/jquery-1.9.1.js"></script>
<script src="http://code.jquery.com/ui/1.10.3/jquery-ui.js"></script>

<script type="text/javascript">
$('.hidden .hidden-content').hide();
$('.hidden > strong').click(function() {
  $(this).parent().find('.hidden-content').toggle();
});
</script>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p>DEFINITION NOT FOUND.</p></div>


</div>
</div></div>
</body>
</html>
